---
title: "プログラミング言語 Roc ってどんなの？"
# image: "/images/tech-blog/slug/image.jpg"
description: "Rocの構想は Elm-inspired らしいので、Rocも自分好みの言語かもしれない。そう思って調べてみた。"
published: "2023-11-29"
updated: "2025-04-13"
category: "tech"
tags: ["roc"]
---

## Roc が気になったきっかけ

最近このツイートを見かけて、ちょっと覗いてみるか、となった。Rocのサイトができたらしい。
[![Rocのポスト](/images/tech-blog/2023-what-is-roc-lang/roc-post.avif)](https://twitter.com/roc_lang/status/1726561636155281803)

[Richard Feldman 氏](https://twitter.com/rtfeldman)が少し前からフルタイムで Roc 言語の開発に取り組んでいることは知っていた。
[![Richard Feldman 氏のポスト](/images/tech-blog/2023-what-is-roc-lang/richard-post.avif)](https://twitter.com/rtfeldman/status/1617575567162851347)

彼は [Elm](https://elm-lang.org/) というプログラミング言語に関わっており、Elmでのプロダクト開発・ライブラリ開発は元より、カンファレンスでの講演や書籍執筆などElm普及に努めていた人物だ。

実は彼はElm開発者 Evan Czaplicki 氏の元上司でもあったのでElmそのものの開発にも携わっていたかもしれない。

Elmは自分のお気に入りの言語で、簡潔さ・堅牢性・高パフォーマンス・開発者フレンドリーといった特徴を持っている。  
Rocの構想は Elm-inspired らしいので、Rocも自分好みの言語かもしれない。

というわけで、Rocがどんな言語なのか気になって覗いてみたというわけだ。

## Roc を利用シーン

例として、以下のシーンで利用できるとのこと。

- CLIで使うスクリプト
- Webサーバー
- 他言語への組み込み
  - Python, Node.js, Swift, WebAssembly, JVM言語などからRocの関数を呼び出し可能らしい。C言語のプログラムを呼び出せるような言語であれば、他の言語でも可能とのこと。

## Rocで書くコードはどんな見た目か

Rocで書かれたコードがどんな見た目をしているのか、ざっくり把握するには [Examples](https://www.roc-lang.org/examples)を見るとわかると思う。

自分はWebサーバー用途のプログラミング言語を探し求めているのもあり、[HTTPリクエストを処理するWebサーバーのExample](https://github.com/roc-lang/basic-webserver/blob/0.1/examples/http.roc)も見てみた。
[このリポジトリに、RocでのWebサーバー実装のサンプルコードが他にもある。](https://github.com/roc-lang/basic-webserver)

[チュートリアル](https://www.roc-lang.org/tutorial#defining-functions) を見ると文法や言語機能はひと通り把握できる。

もし自分で今すぐ書いてみたい場合は、[Web上のREPL](https://www.roc-lang.org/#try-roc)が一番手っ取り早い

ML系言語のよくある感じの文法、機能を持っている。  
こういった言語の書き味はとても好みだ。

昔初めてML系言語を触った時は戸惑ったが、手を動かしながら理解が進んでくるとガラッと印象は変わった。  
Rocも、実は非常にシンプルで、文法が少なく、むしろ簡単な言語だろう。

でも、全く知らない系統の言語に触れる時はどんなものでも大変だとは思う。最初だけは少し頑張る必要があるのは事実だ。

まあ言いたいのは、Rocがあなたにとって見慣れない見た目だとしても、それだけで興味を失わないでね。ってことだ。

## Roc の現状

Roc はまだ開発途中だ。  
2023年11月現在では、バージョニングもまだされていない nightly-build版だ。

現時点では実用的でないからということから、もしかしたら早速Rocへの興味を失ったりしていないか？  
正直に言うと、それが理由で自分の興味度合いもほどほどだ。

まあ、その点がどこまで高まるかは数年後のお楽しみにとっておくということで。

## Roc の特徴(目指しているところ)

繰り返しになるが、Roc はまだ開発途中だ。  
なので、全ての特徴が現時点で完璧に備わっているわけではなく、設計上の理論的言及も含まれている点には注意。

Rocの特徴を見ていく。

### 特徴1. 早い

Rocは2つの意味で早い。

#### まず、実行速度が早い

Rocのコードはマシン言語もしくはWebAssemblyにコンパイルされる。

マシン語ということは、VM上ではなく直接ホストマシンで動く。  
そうなるとJVM系の言語(Java, Scala, Kotlin, etc.)や .NET系の言語(C#, F#, Visual Basic, etc.)などよりも実行速度が一般的には速くなる。

WebAssemblyにコンパイルされる場合も、Node.jsでの高速な実行が期待される。(Node.js環境のJavaScript/TypeScriptよりも高速なことが期待される。)  
ちなみにWebAssemblyということはブラウザ上でも動作しそうに思うが、その点はよくわからなかった。

実行が高速な言語の最高峰にあるのが、C, C++, Zig, unsafe Rust あたりの言語だが、理論上、Rocはこれらには及ばない。  
Rocはメモリ安全な言語であり、かつメモリ管理が自動で行われる(ガベージコレクションのように)。  
メモリ安全でないC, C++には敵わないし、メモリ安全性を捨ててパフォーマンスを上げるような使い方をしたRust (unsafe Rust　と前述したのはこれのこと) にも敵わない。

Rust (safe Rust) は手動メモリ管理が手動であり、自動メモリ管理の言語よりもランタイムオーバーヘッドが少なく、理論上パフォーマンスに優れる。  
Rocは自動メモリ管理なので、safe Rust にも敵わない。

一言で、Roc の実行時パフォーマンスの目標がどのくらいかというと、ガベージコレクションで自動メモリ管理する高速でメインストリームにある言語を上回ることだ。  
Go, C#, Java, JavaScript あたりを超えること。

##### 余談: LLVMについて

ところで、Rocの最適化にはLLVMなどを使っているらしいが、よく知らなかったので調べてみると面白い技術だった。
プログラミング言語の処理系は、大きく以下のものに別れる

- 1.プログラミング言語を**事前に**機械語にコンパイルするもの(いわゆるコンパイル型言語・処理系。C, C++, Rust など)
- 2.プログラミング言語を**実行時に**機械語にコンパイルするもの(いわゆるインタープリター型言語・処理系。Python, Ruby, JavaScript など)
  - 2.1.この派生・改善系としてとして、プログラミング言語を**事前に**機械語ではないバイトコードに変換し、**実行時に**そのバイトコードを機械語にコンパイルするものもある(後述のVM系に似ている)
- 3.プログラミング言語をVM上で動かすためのVM言語(中間言語)に**事前に**コンパイルし、さらにそのVM言語を**実行時**に機械語にコンパイルするもの(いわゆるVM型言語・処理系。Java, Scala, C# など)

一応補足しておくと、一つの言語に対しては様々な処理系が存在する。例えばRubyであっても、インタープリター型の処理系もあればコンパイル型の処理系もVM型の処理系もある。なので、「この言語だからこの型だ」とは一概に言えないので注意。ただ、ほとんどの場合ではRubyのオリジナルの処理系がインタープリター型であり、多くはその処理系で使われるので、インタープリター型の言語だと認識されている。

そしてLLVMについてだが、これは Low Level Virtual Machine の略で、LLVMはコンパイラのフレームワークだ。  
プログラミング言語を LLVM IR (LLVM用の中間表現)へ**実行時**にコンパイルする。そして LLVM IR は**実行前に**機械語にコンパイルされる。  
それも、Mac OS, Linux, Windows などの各OSやアーキテクチャに最適化されたそれぞれの機械語にコンパイルされる。  
一応派生系として、事前には機械語へコンパイルせず、実行時に LLVM IR を機械語へコンパイルするパターンもある。

最適化の部分はLLVMがやってくれるので、プログラミング言語開発者はLLVMへのコンパイルを実装するだけで良い。なんて素敵な技術だ。  
RocはLLVMを使っているので、LLVMがサポートしているOSやアーキテクチャであれば、RocのコードはそれらのOSやアーキテクチャに最適化された機械語にコンパイルされる。

#### また、ビルド速度が早い

開発時のビルドが即時だと感じられるようにすることで、高速な開発の実現を目指している。  
現状だとWebAssembly, Linux x64, Windows x64 では特にビルドが早いとのこと。

また、現時点では development backend (dev環境、devサーバーなどと表現した方が伝わる?)が用意されているのはWebAssemblyのみで、macOSとLinuxではREPLの提供に留まっている。  
Windows対応はまだのようだ。

dev用ではなくproduction用のビルドであれば、現時点でもいずれの環境にも対応している。  
development backend 用のビルドにはLLVMが使えず、直接マシンコードを生成する必要がある、というのが対応ができていない背景にあるらしい。

また、macOS向けのdevelopment backend のビルドは Surgical Linking と呼ばれる仕組みが備わっていない関係で、他よりも目立って遅くなってしまうらしい。  
macOS意外にも、Intel x64 アーキテクチャのものも同じ理由で遅い。

### 特徴2. 開発者フレンドリー

フレンドリーなコミュニティを持つことと、開発者フレンドリーな言語であることを重視しているとのこと。

まず、すっきりと明確な構文を持っていて、フォーマッタが標準で提供されています。  
コーディングスタイルの議論や整形に時間を費やす必要はない。

次に、健全な型システムと支援の行き届いたコンパイラ。  
コンパイルエラーのメッセージは、具体的なエラーの原因箇所と、修正方法の提案、ヒントを与えてくれる。  
健全な型システムに守られているので、実行時エラーに怯えることはかなり抑えられるのはありがたい。  
コードのリファクタリングも思いっきりできる。コードも健全に保ちやすいということだ。  
健全な型システムは個人的にはほぼ必須条件。

他には、テスト用のコマンドや構文も標準で用意されているなどの点がある。

### 特徴3. 関数型

Rocは関数型パラダイムの言語だ。  
最近は関数型あるいはオブジェクト指向を主軸にしつつもマルチパラダイムな言語が多いが、Rocはただ関数型パラダイムのみ。

次のような特徴がある。

- イミュータブル
- 純粋関数
- 副作用よりも作用?(effect) を管理する
  - effect をあまり理解していないのだが、同期処理(副作用)ではなく非同期処理(作用)を管理する、というような表現がされていた。

良さそうなのだが、少し気になった点がある。  
REPLで確認したところ、関数の部分適用はできないみたいだ。関数のカリー化もされない。  
書き方次第ではできるんだろうか？
